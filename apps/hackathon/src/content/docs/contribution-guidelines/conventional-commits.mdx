---
title: Conventional Commits
description: The content of this commit is left as an exercise for the reader.
---

<Callout>
  If you want to be cool, make sure to rebase onto `main` before continuing
  work.
</Callout>

We follow the [Conventional
Commits](https://www.conventionalcommits.org/en/v1.0.0/) specification for
commit messages.

When you hit `enter` after doing `git commit`, it will trigger a [Git Hook](https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks) managed by [Husky](https://typicode.github.io/husky/), which triggers a [Commitlint](https://commitlint.js.org/) command to verify that your commit message meets the specified guidelines. Any messages that do not follow the specification will be rejected with feedback locally.

In order to ease the process of learning the specification and writing compliant commit messages, we've configured [Commitizen](https://commitizen-tools.github.io/commitizen/) to guide you through the process of writing a commit message interactively.
You can run `pnpm commit` to use this tool. This will guarantee that your commit messages are formatted correctly.

With time, writing conventional commit messages will become second nature and you will no longer need to use Commitizen :)

- Each commit should be a single logical change. Don't make several logical changes in one commit. For example, if a patch fixes a bug and optimizes the performance of a feature, split it into two separate commits.
- Each commit should be able to stand on its own, and each commit should build on the previous one. This way, if a commit introduces a bug, it should be easy to identify and revert.
- Each commit should be deployable and not break the build, tests, or functionality.
- If you're not sure if a commit should be split, it's better to split it if each commit is deployable and doesn't break the build, tests, or functionality.
- If you fixed changes in a past commit, use `git commit --amend` to add changes to the previous commit rather than creating a new one; thus keeping the commit history clean and concise.
  - Only exception to this is if the commit already existed on the `main` branch, in which case a fixup commit should be made rather than an amend. If that commit is amended and force pushed, it will diverge the git history for the entire team.
- If you ever amend, reorder, or rebase, your local branch will become divergent from the remote for the amended commit(s), so GitHub won't let you push. Simply force push to overwrite your old branch: `git push --force-with-lease`.

The slight learning curve of writing conventional commits is well worth the effort. It allows us unlock some pretty powerful DevOps which saves the entire team a lot of time in the long run.

### Commit Message Decision Tree

#### Type
```mermaid
flowchart TD
n1["Was it a bug fix or a new/changed feature?"]
n1 --> |"Bug Fix"| n2["fix"]
n1 --> |"New/Changed Feature"| n3["feat"]
n1 --> |"No"| n5["Were only internal config files changed?"]
n5 --> |"Yes"| n6["chore"]
n5 --> |"No"| n7["Was it only documentation content?"]
n7 --> |"Yes"| n8["docs"]
n7 --> |"No"| n9["Was it a CI or build change?"]
n9 --> |"Yes, CI change"| n10["ci"]
n9 --> |"Yes, Build change"| n11["build"]
n9 --> |"No"| n12["Were only tests changed?"]
n12 --> |"Yes"| n13["tests"]
n12 --> |"No"| n14["Are they only performance optimizations?"]
n14 --> |"Yes"| n15["perf"]
n14 --> |"No"| n16["Was it pure code styling/format/semantics?"]
n16 --> |"Yes"| n17["style"]
n16 --> |"No"| n18["refactor"]
```

#### Scope Parameters

##### First level
```mermaid
flowchart TD
n1["Is there a visual difference in the UI?"]
n1 --> |"Yes"| n2["ui"]
n1 --> |"No"| n3["Are the changes only Back-End?"]
n3 --> |"Yes"| n4["api"]
n3 --> |"No"| n5["Leave Scope Blank"]
```

##### Second level

```mermaid
flowchart TD
n1["Which platform(s) was affected?"]
n1 --> |"Marketing Site"| n2["marketing"]
n1 --> |"Hacker Portal App"| n3["app"]
n1 --> |"Docs Site" | n4["docs"]
n1 --> n5["More than one"]
n5 --> n6["marketing,app,docs"]
```
