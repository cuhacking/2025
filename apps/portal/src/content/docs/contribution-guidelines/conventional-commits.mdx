---
title: Conventional Commits
description: The content of this commit is left as an exercise for the reader.
---

<Callout>
  If you want to be cool, make sure to rebase onto `main` before continuing
  work.
</Callout>

We follow the [Conventional
Commits](https://www.conventionalcommits.org/en/v1.0.0/) specification for
commit messages.

When you hit `enter` after doing `git commit`, it will trigger a [Git Hook](https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks) managed by [Husky](https://typicode.github.io/husky/), which triggers a [Commitlint](https://commitlint.js.org/) command to verify that your commit message meets the specified guidelines. Any messages that do not follow the specification will be rejected with feedback locally.

In order to ease the process of learning the specification and writing compliant commit messages, we've configured [Commitizen](https://commitizen-tools.github.io/commitizen/) to guide you through the process of writing a commit message interactively.
You can run `pnpm commit` to use this tool. This will guarantee that your commit messages are formatted correctly.

With time, writing conventional commit messages will become second nature and you will no longer need to use Commitizen :)

- Each commit should be a single logical change. Don't make several logical changes in one commit. For example, if a patch fixes a bug and optimizes the performance of a feature, split it into two separate commits.
- Each commit should be able to stand on its own, and each commit should build on the previous one. This way, if a commit introduces a bug, it should be easy to identify and revert.
- Each commit should be deployable and not break the build, tests, or functionality.
- If you're not sure if a commit should be split, it's better to split it if each commit is deployable and doesn't break the build, tests, or functionality.
- If you fixed changes in a past commit, use `git commit --amend` to add changes to the previous commit rather than creating a new one; thus keeping the commit history clean and concise.
  - Only exception to this is if the commit already existed on the `main` branch, in which case a fixup commit should be made rather than an amend. If that commit is amended and force pushed, it will diverge the git history for the entire team.
- If you ever amend, reorder, or rebase, your local branch will become divergent from the remote for the amended commit(s), so GitHub won't let you push. Simply force push to overwrite your old branch: `git push --force-with-lease`.

The slight learning curve of writing conventional commits is well worth the effort. It allows us unlock some pretty powerful DevOps which saves the entire team a lot of time in the long run.

### Commit Message Decision Tree

#### Type

```mermaid
flowchart TD
n1["Was it a bug fix or a new/changed feature?"]
n1 --> |"Bug Fix"| n2["fix"]
n1 --> |"New/Changed Feature"| n3["feat"]
n1 --> |"No"| n5["Were only internal config files changed?"]
n5 --> |"Yes, just configs"| n6["chore(config/...):"]
n5 --> |"No"| n7["Was it only documentation content?"]
n7 --> |"Yes"| n8["docs"]
n7 --> |"No"| n9["Was it a CI or build change?"]
n9 --> |"Yes, CI change"| n10["ci"]
n9 --> |"Yes, Build change"| n11["build"]
n9 --> |"No"| n12["Were only tests changed?"]
n12 --> |"Yes"| n13["tests"]
n12 --> |"No"| n14["Are they only performance optimizations?"]
n14 --> |"Yes"| n15["perf"]
n14 --> |"No"| n16["Was it pure code styling/format/semantics?"]
n16 --> |"Yes"| n17["style"]
n16 --> |"No"| n18["refactor"]
```

#### Scope Parameters

##### First level

```mermaid
flowchart TD
n1["Is there a visual difference in the UI?"]
n1 --> |"Yes"| n2["ui"]
n1 --> |"No"| n3["Was it just configs?"]
n3 --> |"Yes"| n4["config"]
n3 --> |"No"| n5["Are the changes only Back-End?"]
n5 --> |"Yes"| n6["api"]
n5 --> |"No"| n7["Leave Scope Blank"]
```

##### Second level

```mermaid
flowchart TD
n1["Which platform(s) was affected?"]
n1 --> |"Marketing Website"| n2["web"]
n1 --> |"Hacker Portal"| n3["portal"]
n1 --> |"Docs Site" | n4["docs"]
n1 --> n5["More than one"]
n5 --> n6["web+portal+docs"]
```

The platforms should always be in the same order: `web`, `portal`, `docs`.
If you have changes in the `portal` only, the scope should be `portal`.
If you have changes in all three platforms, the scope should be `web+portal+docs`.
So if you have changes in the `web` and `docs`, the scope should be `web+docs`, not `docs+web`.

### Examples

Here are some examples of commit messages following the decision tree guidelines:

```bash
# Hacker Portal bugfix that affects the UI
fix(ui/portal): dashboard login button misaligned on mobile

# A new feature in the API for both the Marketing Website and Hacker Portal, no change in the UI
feat(api/web+portal): create user data retrieval endpoints

# A change in the build process for the Docs Site
build(docs): update webpack configuration for bundling mdx files

# Change in documentation content on the Docs Site
docs(contribution-guidelines): add pnpm install commands

# Change in UI feature on the Docs Site
feat(ui/docs): change header search bar background to purple-300

# A performance optimization in the API for the Hacker Portal
perf(api/portal): optimize database queries for sponsor data

# A code styling update for button components in the marketing website
style(web/components): change button border radius to 5px

# Testcase refactor for Hacker Portal
refactor(tests): re-structure user registration cases
```
